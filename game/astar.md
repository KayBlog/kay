[<< 返回到主页](index.md)

**这里将介绍寻路算法的博客文章**  

目前在寻路算法中，使用最多的就是AStar算法。A*算法原理很简单。   
A*存在的缺陷：  
1. 需要对地形单位化分块，基于这个来计算   
2. 当地图比较大，则分快很多，计算量会比较大  
3. A*只能上下左右，或者加上斜方向最多8方向，不够真实   
4. 若物体的体积比较大，可能显示时碰到不可行走区域   

为了解决上面的一些问题，使用路点WayPoint来计算路径。路点的自由添加，可以减小AStar的节点数量。缺陷：  
1. 大地图，路点数量太少显得生硬  
2. 需要考虑的比较多，比如直线上忘记加路点，会出现绕着走到目的地。   

为了更好的解决上面的问题，导航网格Navmesh出现了。导航网格可以看成是对可行走区域进行凸分解，得到很多凸多边形。  
有点：  
1. 几点数量大大减少，且多边形覆盖任意区域，而不用分块。编辑操作的效率也大大提高    
2. 通过计算直线两点和网格的相邻点的关系位置，可以计算两点是否可以直接行走，不用想分块或者路点绕过去  
3. 转角方位不一定经过相邻点，可以加上单位体积的半径，这样不同体积的物体都可以合理的通过转角   

对于静态地图，可以使用navmesh生成导航网格，然后对凸多边形的每一条边取中点作为路点Waypoint并建立路点之间的连接。然后用Dijkstra算法预先计算好最短路径。Dijkstra是单源多路径，不是启发式算法，最终计算的结果是最优可靠的，Dijkstra不适应动态的地图。  
导航网格Navmesh可由recast生成，导航网格多边形共边为1的边外面是不可行走区域。   
[Recast生成NavMesh可参考](http://www.critterai.org/projects/nmgen_study/detailgen.html)    

接下来介绍Steer Behaviour实时寻路算法。目前做的项目基于SourceForge [OpenSteer](https://sourceforge.net/projects/opensteer/?source=directory)   













