[<< 返回到上级](index.md)

**这里将介绍计算机图形学坐标系的博客文章**

眼睛观察整个3D空间时，能看到形形色色的物体以及各种灯光的效果,接下来用不同的空间来看待这些物体

[1. 本地或局部坐标系](#1)   
[2. 世界坐标系](#2)  
[3. 相机空间坐标系](#3)  
[4. 投影变换与齐次裁剪空间](#4)  
[5. 视口变换](#5)  

在介绍坐标系之前，先想一下这个场景：在游戏场景里，存在着许多物体。这些物体是美术在模型软件上制作出来的，那么就有这样一个问题：美术制作模型依赖一个坐标系，模型放置在场景里存在一个坐标系，这样存在两个坐标系。接下来分析这两个坐标系。

<span id="1"></span>
## **1. 本地或局部坐标系**  
 
如果模型不放在场景里，那么模型的顶点数据我们认为是定义在一个坐标系下的，当把整个模型放置在场景里后，那么可以理解为讲一个坐标系放在了另一个坐标系下，这里就存在一个相对概念。比如模型的顶点数据在自身的坐标系下是P，那在场景里的坐标系下坐标是多少呢？这里就延伸出本地坐标系，这个是美术制作模型时的那个坐标系；另一个是世界坐标系，即模型所放置得坐标系。模型放置在世界坐标系下后，我们可以将本地坐标系称为局部坐标系。另一个延伸就是局部坐标系与世界坐标系存在一个转化关系，即局部坐标系下的顶点在世界坐标系下的位置，以及世界坐标系下的顶点在局部坐标系下的位置。延伸出模型变换矩阵M及逆矩阵M^(-1)。  
这样你可以理解本地坐标系，局部坐标系和世界坐标系了。


<span id="2"></span>
## **2. 世界坐标系**  

接上面来分析，局部坐标系在世界坐标系下，存在缩放变化：将模型的点数据进行拉伸或缩小变化；旋转变化：对模型的点数据绕一个旋转轴进行旋转；平移变化：对模型点数据延某一个方向移动。  
注意：如果模型默认加载到世界里，本地坐标系和世界坐标系的原点是重合的，且没有缩放。至于有没有旋转变化，要看本地坐标系与世界坐标系的xyz轴是否一致。如果不一致，则会出现旋转。  
这样看，局部坐标系是世界坐标系的子坐标系，中间存在一个变换矩阵M，即可将模型本地的数据转换到世界坐标系下。   

另外，世界坐标系下存在多个物体，即存在多个局部坐标系。则可以通过世界坐标系将多个局部坐标系连接起来。比如局部坐标系1与世界坐标系的变换矩阵为M1，局部坐标系与世界坐标系的变换矩阵M2，那么局部坐标系1本地点P1，在局部坐标系2下点的数据，可以通过将P1通过P1 \* M1得到在世界坐标系的位置W1，然后通过M2点逆矩阵M2^（-1） \* W1得到在局部坐标系2下对本地坐标系P2，即P2 = P1 \* M1 \* M2^(-1)矩阵的乘法从右往左乘)。那么局部坐标系1到局部坐标系2的变换矩阵为 M2^(-1) \* M1  

变换矩阵由缩放，旋转和平移变换累积得到，故只需要清楚缩放系数，旋转值，平移值即可得到最终的变换矩阵。在3D中，缩放由（x， y， z）3个浮点确定， 旋转由（x, y, z, w）四元素4个浮点确定，平移由（x，y，z）3个浮点数确定。则父坐标系与子坐标系需要10个浮点数可以确定其关系。
注意：旋转有时用欧拉角表示，但其存在一个主要问题：旋转轴重合导致万像锁，则3D退化为2D，计算不正确。另外由一个16浮点的矩阵表示，存在2个问题：1. 16个浮点数据量大 2. 不支持插值计算。而四元素没有上面的几个问题，但并不是很直观清楚是怎样旋转的。  

<span id="3"></span>
## **3. 相机空间坐标系**  

如果用一双眼睛去看整个世界上的物体，则延伸出相机的概念，即物体在相机空间的表示。  
相机空间的确定：相机的位置和相机的朝向。一般情形，我们默认相机的x轴始终与世界坐标系的xoz平面平行，则相机的朝向就能确定相机模型所在世界坐标系下的旋转变换。同时，相机的缩放是没有意义的，即默认不会有缩放变换。另外，相机的位置确定了平移变换。综上，相机所确定的空间被唯一的建立起来。  

简单来说，世界空间中所有的物体需要在相机局部坐标系表示，推到请看上面。将M2^(-1)定义为V，即世界坐标下的点变换到相机空间下，则模型视图变换矩阵为MV。

<span id="4"></span>
## **4. 投影变换与齐次裁剪空间**

接着上面聊，为了模拟真实的世界，远处的物体看上去比近处的物体小，并且相机存在一个视野范围(太近的物体可能看不到，后面的物体看不见)，则对相机再加以限制：Frustum View，视锥体(由6个平面构成封闭空间)    
1 近平面near，远平面far：确定视线范围，前后两个平面。其中near为裁剪平面
2 apsect ：确定宽高比 ，左右两个平面  
3 fov： field of view。一个角度值，确定上下两个平面  
故4个参数可以确定唯一的截头体空间。并且由这4个值，可以确定一个变换矩阵：P（透视投影变换矩阵）  
透视投影变换矩阵是将截头体空间变换到一个立方体或者长方体，我们成这个空间为齐次裁剪空间。具体的推导过程有很多文章介绍，随便查找即可了解。  
综上所诉，则可以将模型的点经过MVP变换到CVV空间。  
*注意：此处的变换为齐次坐标系，顶点以（x，y，z，1）形式表示。*  

齐次裁剪空间在到计算CVV规则观察空间，  
1. 齐次空间做裁剪(截头体不好做裁剪，需转化到立方体或长方体内)  
2. 进行透视除法(除以w值)，才是CVV空间  
3. 裁剪必须在透视除法之前进行，可以插值计算。  

齐次裁剪空间是经过一系列的仿射变换得到，而仿射变换是不改变点的属性关系，故可以进行线性插值。而裁剪范围是由CVV空间确定，则需要从透视除法中的点计算齐次空间中的点，然后再进行裁剪。

具体的裁剪步骤：  
1. 经过投影变化后得到其次坐标  
2. 根据规范化立方体所确定的裁剪空间求得齐次空间中进行线性插值的参数  
3. 利用该参数对齐次空间中的点进行线性插值，包括坐标，纹理，颜色等  

在处理透视投影变换时，z值会出现Z fighting问题，当点数据越靠近远平面时越明显，具体可以由公式观察。可以尽量减小近平面和远平面的数据。

GPU的裁剪算法不是这么计算，具体做法可以查询其他资料。  

<span id="5"></span>
## **5. 视口变换**  

接着上面聊，最后计算的点坐标值即CVV下的值（可以看成是NDC，归一化设备坐标），根据视口变换viewport(起始位置x,y值，宽w和高h，x轴向右为正，y轴向下为正。是整个屏幕)，进行放大(主要针对x，y值)，即此处主要是一个缩放过程  

1. 另有glDepthRange限制深度值范围  
2. 屏幕坐标系分以左下角和左上角为原点，看操作系统，大多数以左下角为原点  





