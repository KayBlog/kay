[<< 返回到主页](index.md)

**这里将介绍匹配或指派问题**  

匹配不是指字符串KMP算法，而是图论里常见的二部图的匹配。   
指派问题很常见，主要将n个事项指派到m个人使得完成的效率最快。  

**指派**   
指派问题可以看成0-1规划问题。指派问题中需解决m个人处理n个事项，当然每个人对每个事项的强弱不一样，用权重weight来表示。   
对上面人数和事项在数量上划分，有如下3中情形：  
1. 当m = n时   
2. 当m > n时    
3. 当m < n时    
另外，还有限制条件为：某人i不能做某事j；某人i可以做多件事；   
当人少事多时，添加虚拟的人，设其费用为0；当人多事少时，添加虚拟的事，设置费用为0；当某人不能做某事时，将其费用设置为最大值；某人可以做多件事时，可以将人赋值一份，变成2n个人做m个事，然后再比较2n和m的大小，设置虚拟的人或者事。   

上面处理过程得到效率矩阵必须是方阵，行数和列树要一致。   
处理指派问题，最简单的算法是 **匈牙利算法**.   

匈牙利基本原理：  
1. 将效率矩阵的某一行（或某一列）的各个元素都减去同一个常数t(可正可负)，得到新的矩阵，则新的矩阵为效率矩阵的指派问题与原指派问题的最优解相同。但其最优质比原最优质减少t。  

在效率矩阵C中，有一组处于不同行、不同列的零元素，称为独立的零元素组，每个元素称为独立零元素。  

2. 效率矩阵C中独立零元素的最多个数等于能覆盖所有零元素的最少直线数   

算法步奏：  
1. 效率矩阵先对每行减去最小的树，则每行中都会出现零元素；接着对列中不包含零元素的减去最小的树，则该列就会出现零元素。   
2. 圈0法，确定新的效率矩阵中独立0元素。若独立0元素的个数等于n，则找到最优解；若小于n，则转入第3步  
    1. 独立0元素的定义为：独立0元素的位置(i,j)，所有的i值不相等和所有的j值不相等   
    2. 遍历所有0元素(i,j)，效率矩阵去除第i行和第j列，则得到一个小一阶的矩阵；重复上面步骤，直到找不到0元素。  
3. 做最少直线覆盖当前所有零元素   
    1. 对没有圈0的行，标记true  
    2. 对已标记true的行中，对零元素所在的列标记为true  
    3. 在标记位true的列中，对圈0的元素所在的行标记为true  
    4. 重复(2)和(3)，直到再也找不到可以标记为true的行或列  
    5. 对没有标记为true的行，画横线；对没有标记为true的列，画纵线   

4. 继续变换矩阵，增加0的个数。
    1. 在未被直线覆盖的元素中，找出最小的元素，然后所在行或列减去这一个元素。  
    2. 这样未被直线覆盖的元素中肯定会出现0元素，但同时会是已覆盖的元素中出现负数，则只要对他们所在的列或行中各个元素加上这个最小元素。  
    3. 返回到第(2)步  


**匹配**  
匹配相关的概率有：  
二分图：将点分成两组不相交的点集U和V。如果存在这样的一个划分，则此图为一个二分图。  
匹配：匹配是边的集合。其中任意两条边都没有公共顶点。则延伸出匹配点、匹配边、未匹配点和非匹配边。  
最大匹配：一个图所有的匹配中，所含边数最多的匹配，称为最大匹配。   
完美匹配：一个匹配中，所有的点都是匹配点，则它是一个完美匹配。完美匹配是最大匹配的一种特殊形式。并非所有的图都存在完美匹配。  

求解最大匹配问题的一个算法是匈牙利算法，介绍这个算法之前先认识两个概念：   
交替路：从一个未匹配点出发，依次经过非匹配边，匹配边，非匹配边...形成的路径交交替路   
增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点，则这条交替路称为增光路。  

增光路的一个重要的性质：非匹配边比匹配边多一条。因此研究增广路的意义在于改进匹配，把增光路中的匹配边和非匹配边交换，则匹配边就比原来的多1。若找不到增广路，则达到最大匹配。匈牙利算法正是这么处理的，一般由BFS构造匈牙利树。  

匈牙利算法：  
1. 从左边第1个点开始，挑选未匹配点进行搜索，寻找增广路。  
    1. 如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数+1，停止搜索。  
    2. 如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一颗匈牙利树，可以永久性的删除。  
2. 由于找到增广路之后，需要沿着路径更新匹配，则需要一个结构来记录路径上的爱你。  










