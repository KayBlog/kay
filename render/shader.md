[<< 返回到主页](index.md)

**这里将介绍延迟光照和延迟着色的博客文章**   

延迟着色和延迟光照  
 延迟着色(Deferred Sahder)  
1. 对比传统着色(Forward Shader),一个着色器进行整个渲染工作，渲染过程分为两部分：   
    1. 深度测试，找到可视点   
    2. 对每个表面点，着色计算  

2. 传统着色的问题  
    1. 这个过程是一个物体一个物体顺序进行，会出现后一个物体覆盖前一个物体的情形，从而导致很多不必要的计算。  
    2. 过度绘制计算，发生于表面着色计算(不必要的就是着色计算)   
    
3. 延迟着色，处理的问题  
    1. 将着色过程和深度测试分离，使着色过程在深度测试之后，最终的片元都是可视点  
    
4. 延迟着色 框架(着色参数，使用几何缓存存储，G_buffer. MRT)   
```
    forward shader 前向着色  
      for each opaque object (所有不透明物体)  
         write parameters G_buffer(将参数存储到G_buffer中)          
    2. deffer shader 延迟着色  
      for each light  
         write pixel color Accumulate buffer (累积缓存)         
    3. forward shader 传统渲染
      foreach transparent object (所有透明或半透明物体)
         write color
```

5. 优点  
    1. 支持数量巨大的光源，保证稳定的帧率  
    2. 解决过渡绘制问题  
    
6. 缺点  
    1. 牺牲了内存，过大的G_buffer  
    2. 不支持半透明物体  
    3. 内存访问的带宽问题(同样带来新的过度绘制)(延迟光照和光源分配两个方案)  
    4. 对屏幕区域的像素点而不是每个物体自身进行着色，这样不好控制物体自定义着色器(着色器管理)  
    
7. 针对缺点：内存访问带宽问题  
```
    1. foreach light  
        1. foreach pixel  
            1. read G_buffer  
            2. compute shading  
            3. read + write frame buffer  
    2. 则着色器对帧缓存执行：读取 计算 写入操作。如果一个像素点被多个光源覆盖，
    则这个像素点会被多次读写，带来新的过度绘制   
```

**方案一：光源分配**   
将光源放在双重循环的内部，找出每个像素点被哪些光源覆盖，然后再计算，只需要一次读写找出所覆盖的光源集合，也是一个问题  
```
    foreach pixel
        valid_lights
        foreach light
            if (condition)
                valid_lights.add(light)
        read G_buffer
        foreach valid_lights
            compute shading
        read + write frame buffer
```
    
**方案二：延迟光照**    进一步将着色计算与光照计算分离出来。G_buffer只需要32位存储法线矢量，大大减少带宽占用            
延迟光照：解决延迟着色里头，光源循环导致帧缓存数据重复读取计算资源浪费   
1. 渲染方程， 漫反射和高光反射部分组成  
2. 反射率由材质提供，为常数  
3. 渲染方程，与 法向和高光扩散系数 有关，只需要一个32位颜色缓存 G_buffer  
4. 两个累积缓存，存储 漫反射和高光反射部分的 辐射照度 g_diff 和 d_spec  
5. 几何阶段：几何体(第一次几何通道)到 法线缓存(深度，法线，高光扩散系数)  
    1. 光照计算阶段：光照计算 到 光照累积缓存  
    2. 着色计算阶段：着色计算（第二次几何通道）  
6. 全过程    
    1. 渲染场景中所有不透明物体，将法线和高光扩散系数写入到 颜色缓存  
    2. 计算光照，对光源覆盖的每个屏幕像素点进行计算；计算辐射照度，并将漫反射和高光反射 辐射照度 写入到两个累积缓存中，即延迟光照计算   
    3. 重新渲染所有不透明几何体，此时不进行光照计算，从两个颜色累积缓存中读取数据，进行着色计算，写入到帧缓存中，此阶段为第二次几何通道  
    4.  绘制所有半透明的物体  

光源分配：分块着色和分簇着色   
着色器管理：针对像素着色，则一块区域内的像素，包含了多种材质  
1. 特殊材质，场景大量物体表面的材质比较统一  
2. 神秘海域4 延迟着色阶段使用计算着色器以块为单位进行渲染，每块为16*16个像素点  
    1 对每个块执行材质类型定义  
    2 对每个材质类型分别执行一次计算着色器  
    使用一个查存表，存储材质的可能组合  
    
延迟着色的反走样： MSAA  
1. 形态反走样  
2. 时间反走样  
3. 聚集几何缓存反走样  