[<< 返回到主页](index.md)

**这里将介绍一种性能不错的麻将算法**  

1. 胡牌模式(包含了清一色，混一色等特殊牌型)分：   
**14张**   
```
[[1,1,1],[1,1,1],[1,1,1],[1,1,1],[2]]
[[1, 1, 1], [1, 1, 1], [1, 1, 1], [3], [2]]
[[1, 1, 1], [1, 1, 1], [3], [3], [2]]
[[1,1,1],[3],[3],[3],[2]]
[[3],[3],[3],[3],[2]]
```
**11张**  
```
[[1,1,1],[1,1,1],[1,1,1],[2]]
[[1,1,1],[1,1,1],[3],[2]]
[[1,1,1],[3],[3],[2]]
[[3],[3],[3],[2]]
```
**8张**   
```
[[1,1,1],[1,1,1],[2]]
[[1,1,1],[3],[2]]
[[3],[3],[2]]
```
**5张**  
```
[[1,1,1],[2]]
[[3],[2]]
```
**2张**   
```
[[2]]
```
**七对子**   
```
[[2], [2], [2], [2], [2], [2], [2]] 
```

2. 碰，吃，杠等基础操作，选择贪心策略(只要玩家手里存在，就给提示)，这里不做处理   
3. 对每种模式，做一个全排列并去掉重复的，得到所有模式   
```
    ，比如
    [[1,1,1],[1,1,1],[1,1,1],[1,1,1],[2]]
    全排列为
    [[1,1,1],[1,1,1],[1,1,1],[1,1,1],[2]]
    [[1,1,1],[1,1,1],[1,1,1],[2],[1,1,1]]
    [[1,1,1],[1,1,1],[2],[1,1,1],[1,1,1]]
    [[1,1,1],[2],[1,1,1],[1,1,1],[1,1,1]]
    [[2]，[1,1,1],[1,1,1],[1,1,1],[1,1,1]]
    ，以及
    [[2], [2], [2], [2], [2], [2], [2]]
    全排列为
    [[2], [2], [2], [2], [2], [2], [2]]
```
4 接下来每种模式再扩展新的模式  
```
    ，比如 size = 4
    索引      0       1       2     3
    数据  [[1,1,1],[1,1,1],[1,1,1],[2]]
    for (int i = 0; i < size; ++i)
    {
        for (int j = i + 1; j < size; ++j)
        {
            i和j的数据做一个如下计算
            （假定i=0，j=1，则数据为
            di = [1,1,1], dj = [1,1,1]
            di的sizei=3
            dj的sizej=3）
            a 创建一个数组 t = [sizej个0，di，sizej个0]
              此时 t = [0 0 0 1 1 1 0 0 0]
            b 将dj与t数据向量求和，然后移动1位。类似做个卷积，即
                dj =[1,1,1]
                t = [0 0 0 1 1 1 0 0 0]
                dj每次计算都向右边移动1位，移动 sizei + sizej 次，总共计算sizei + sizej + 1次
                (移动第一次，为
                    dj =  [1,1,1]
                    t = [1 1 1 1 1 1 0 0 0]
                )

            c 2步奏计算一次得到一个模式
                第一次的计算得到 t = [1 1 1 1 1 1] (这里需要去除为0的数据)
                模式为 [[1 1 1 1 1 1],[1,1,1],[1,1,1],[2]]

            d 3步计算得到的模式，递归计算得到该模式的所有模式
                
        }
    }
```
5. 对4做一些缓存优化(针对递归)，搜集得到所有的模式   
6. 每一种模式都是一种胡牌的类别，最后对模式进行分析    
```
    // ret
    //   3bit  0: 三个一样的 个数(0～4)
    //   3bit  3: 顺子的个数(0～4)
    //   4bit  6: 将的个数(1～13)
    //   4bit 10: 保留的位置１(0～13)
    //   4bit 14: 保留的位置２(0～13)
    //   4bit 18: 保留的位置３(0～13)
    //   4bit 22: 保留的位置４(0～13)
    //   1bit 26: 胡牌的类型
    //   1bit 27: 胡牌的类型
    //   1bit 28: 胡牌的类型
    //   1bit 29: 胡牌的类型
    //   1bit 30: 胡牌的类型
    a 遍历的方式处理
    b 现确定将
    c 顺子优先或3个优先进行处理
    d 计算得到 顺子的个数，3个的个数
    e 通过分析确定胡牌类型(七小对，清一色等)
```
7. 输出最后的结果对 (胡牌的模式以及对应胡牌的牌型)   